\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{verbatim}

\geometry{left=2cm,right=2cm,top=2cm,bottom=2cm}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}

\input{title}

\tableofcontents
\pagebreak

\section{Условие задачи}

\subsection*{Цель работы}
Приобретение практических навыков в:
\begin{itemize}
    \item Освоение принципов работы с файловыми системами
    \item Обеспечение обмена данных между процессами посредством технологии «File mapping»
\end{itemize}

\subsection*{Задание}
Пользователь вводит команды вида: «число число число<endline>». Далее эти числа передаются от родительского процесса в дочерний. Дочерний процесс производит деление первого числа на последующие, а результат выводит в файл. Если происходит деление на 0, то дочерний и родительский процесс завершают свою работу. Проверка деления на 0 должна осуществляться на стороне дочернего процесса. Числа имеют тип float. Количество чисел может быть произвольным.

\subsection*{Вариант}4

\section{Метод решения}

Программа реализует взаимодействие между родительским и дочерним процессами с использованием разделяемой памяти (memory-mapped files). Основной алгоритм:

\subsection*{Архитектура программы}
\begin{itemize}
    \item \textbf{Родительский процесс}: управляет вводом данных от пользователя, созданием дочернего процесса и передачей данных через разделяемую память
    \item \textbf{Дочерний процесс}: выполняет операции деления и записывает результаты в файл
    \item \textbf{Разделяемая память}: используется для обмена данными между процессами
\end{itemize}

\subsection*{Алгоритм работы}
\begin{enumerate}
    \item Родительский процесс создает разделяемую память и инициализирует структуру данных
    \item Создается дочерний процесс с помощью системного вызова \texttt{fork()}
    \item Пользователь вводит числа через родительский процесс
    \item Числа передаются в дочерний процесс через разделяемую память
    \item Дочерний процесс выполняет деление первого числа на последующие
    \item Результаты записываются в файл
    \item При обнаружении деления на ноль оба процесса завершают работу
\end{enumerate}

\subsection*{Взаимодействие процессов}
Программа использует механизм разделяемой памяти (shared memory) для обмена данными между процессами. Синхронизация осуществляется с помощью атомарных флагов.

\subsection*{Обработка ошибок}
\begin{itemize}
    \item Проверка деления на ноль в дочернем процессе
    \item Обработка ошибок создания разделяемой памяти
    \item Обработка ошибок открытия файла для записи
\end{itemize}

\section{Описание программы}

\subsection*{Структура программы}
\begin{itemize}
    \item \textbf{division\_parents.cpp} - родительский процесс
    \item \textbf{division\_child.cpp} - дочерний процесс  
    \item \textbf{division\_os.h/cpp} - вспомогательные функции для работы с процессами и разделяемой памятью
    \item \textbf{shared\_data.h} - структура данных для разделяемой памяти
\end{itemize}

\subsection*{Основные типы данных}
\begin{itemize}
    \item \texttt{SharedData} - структура для хранения данных в разделяемой памяти:
    \begin{itemize}
        \item \texttt{data\_ready} - флаг готовности данных для обработки
        \item \texttt{processing\_complete} - флаг завершения обработки
        \item \texttt{division\_by\_zero} - флаг обнаружения деления на ноль
        \item \texttt{terminate\_process} - флаг завершения работы
        \item \texttt{numbers\_count} - количество чисел
        \item \texttt{numbers[100]} - массив чисел
        \item \texttt{filename} - имя файла для записи результатов
    \end{itemize}
    \item \texttt{ProcessRole} - перечисление для идентификации роли процесса
\end{itemize}

\subsection*{Ключевые функции}

\subsubsection*{Основные функции}
\begin{itemize}
    \item \texttt{ProcessCreate()} - создание дочернего процесса
    \item \texttt{create\_shared\_memory()} - создание разделяемой памяти
    \item \texttt{open\_shared\_memory()} - открытие существующей разделяемой памяти
    \item \texttt{close\_shared\_memory()} - закрытие разделяемой памяти
\end{itemize}

\subsubsection*{Логика процессов}
\begin{itemize}
    \item \textbf{Родительский процесс}: ввод данных, передача в разделяемую память, ожидание результатов
    \item \textbf{Дочерний процесс}: чтение данных из разделяемой памяти, выполнение деления, запись в файл
\end{itemize}

\subsection*{Используемые системные вызовы}
\begin{itemize}
    \item \textbf{fork()} - создание нового процесса
    \item \textbf{shm\_open()} - создание/открытие разделяемой памяти
    \item \textbf{mmap()} - отображение разделяемой памяти в адресное пространство процесса
    \item \textbf{munmap()} - удаление отображения разделяемой памяти
    \item \textbf{shm\_unlink()} - удаление разделяемой памяти
    \item \textbf{wait()} - ожидание завершения дочернего процесса
\end{itemize}

\section{Исходный код программы}

\subsection*{Заголовочные файлы}

\lstinputlisting[language=C++,caption=shared\_data.h - структура разделяемой памяти,captionpos=b]{shared_data.h}

\lstinputlisting[language=C++,caption=division\_os.h - вспомогательные функции,captionpos=b]{division_os.h}

\subsection*{Реализация функций}

\lstinputlisting[language=C++,caption=division\_os.cpp - работа с процессами и памятью,captionpos=b]{division_os.cpp}

\subsection*{Основные процессы}

\lstinputlisting[language=C++,caption=division\_parents.cpp - родительский процесс,captionpos=b]{division_parents.cpp}

\lstinputlisting[language=C++,caption=division\_child.cpp - дочерний процесс,captionpos=b]{divisoin_child.cpp}

\section{Системные вызовы программы}

\begin{verbatim}
22:16:45.809239 execve("./division_parents", ["./division_parents"], 0x7ffe80dd98c8 /* 65 vars */) = 0
22:16:45.810684 brk(NULL)               = 0x593b26cb4000
22:16:45.810915 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x70a91c6a9000
22:16:45.811138 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
22:16:45.811317 openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
22:16:45.811362 fstat(3, {st_mode=S_IFREG|0644, st_size=56283, ...}) = 0
22:16:45.811390 mmap(NULL, 56283, PROT_READ, MAP_PRIVATE, 3, 0) = 0x70a91c69b000
22:16:45.811546 close(3)                = 0
22:16:45.811574 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libstdc++.so.6", O_RDONLY|O_CLOEXEC) = 3
22:16:45.811602 read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0\0\0\0\0\0\0\0"..., 832) = 832
22:16:45.811624 fstat(3, {st_mode=S_IFREG|0644, st_size=2592224, ...}) = 0
22:16:45.811644 mmap(NULL, 2609472, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x70a91c400000
22:16:45.811667 mmap(0x70a91c49d000, 1343488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x9d000) = 0x70a91c49d000
22:16:45.811693 mmap(0x70a91c5e5000, 552960, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e5000) = 0x70a91c5e5000
22:16:45.811715 mmap(0x70a91c66c000, 57344, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x26b000) = 0x70a91c66c000
22:16:45.811742 mmap(0x70a91c67a000, 12608, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x70a91c67a000
22:16:45.811774 close(3)                = 0
22:16:45.811797 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
22:16:45.811821 read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\220\243\2\0\0\0\0\0"..., 832) = 832
22:16:45.811840 pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
22:16:45.811859 fstat(3, {st_mode=S_IFREG|0755, st_size=2125328, ...}) = 0
22:16:45.811879 pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
22:16:45.811896 mmap(NULL, 2170256, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x70a91c000000
22:16:45.811923 mmap(0x70a91c028000, 1605632, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x70a91c028000
22:16:45.811949 mmap(0x70a91c1b0000, 323584, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b0000) = 0x70a91c1b0000
22:16:45.811972 mmap(0x70a91c1ff000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1fe000) = 0x70a91c1ff000
22:16:45.811999 mmap(0x70a91c205000, 52624, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x70a91c205000
22:16:45.812030 close(3)                = 0
22:16:45.812054 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libm.so.6", O_RDONLY|O_CLOEXEC) = 3
22:16:45.812077 read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0\0\0\0\0\0\0\0"..., 832) = 832
22:16:45.812097 fstat(3, {st_mode=S_IFREG|0644, st_size=952616, ...}) = 0
22:16:45.812117 mmap(NULL, 950296, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x70a91c317000
22:16:45.812140 mmap(0x70a91c327000, 520192, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x10000) = 0x70a91c327000
22:16:45.812271 mmap(0x70a91c3a6000, 360448, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x8f000) = 0x70a91c3a6000
22:16:45.812700 mmap(0x70a91c3fe000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0xe7000) = 0x70a91c3fe000
22:16:45.812935 close(3)                = 0
22:16:45.813274 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libgcc_s.so.1", O_RDONLY|O_CLOEXEC) = 3
22:16:45.813672 read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0\0\0\0\0\0\0\0"..., 832) = 832
22:16:45.814014 fstat(3, {st_mode=S_IFREG|0644, st_size=183024, ...}) = 0
22:16:45.814378 mmap(NULL, 185256, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x70a91c2e9000
22:16:45.814670 mmap(0x70a91c2ed000, 147456, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x4000) = 0x70a91c2ed000
22:16:45.814881 mmap(0x70a91c311000, 16384, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x70a91c311000
22:16:45.815085 mmap(0x70a91c315000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x2b000) = 0x70a91c315000
22:16:45.815267 close(3)                = 0
22:16:45.815425 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x70a91c699000
22:16:45.815660 arch_prctl(ARCH_SET_FS, 0x70a91c69a500) = 0
22:16:45.815788 set_tid_address(0x70a91c69a7d0) = 25039
22:16:45.815933 set_robust_list(0x70a91c69a7e0, 24) = 0
22:16:45.816020 rseq(0x70a91c69ae20, 0x20, 0, 0x53053053) = 0
22:16:45.816304 mprotect(0x70a91c1ff000, 16384, PROT_READ) = 0
22:16:45.816533 mprotect(0x70a91c315000, 4096, PROT_READ) = 0
22:16:45.816943 mprotect(0x70a91c3fe000, 4096, PROT_READ) = 0
22:16:45.818517 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x70a91c697000
22:16:45.819014 mprotect(0x70a91c66c000, 45056, PROT_READ) = 0
22:16:45.819202 mprotect(0x593b0e043000, 4096, PROT_READ) = 0
22:16:45.820309 mprotect(0x70a91c6e7000, 8192, PROT_READ) = 0
22:16:45.820449 prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
22:16:45.820661 munmap(0x70a91c69b000, 56283) = 0
22:16:45.820887 futex(0x70a91c67a7bc, FUTEX_WAKE_PRIVATE, 2147483647) = 0
22:16:45.821102 getrandom("\x44\x2d\xa4\xa2\x40\xd3\x32\xf7", 8, GRND_NONBLOCK) = 8
22:16:45.821358 brk(NULL)               = 0x593b26cb4000
22:16:45.821435 brk(0x593b26cd5000)     = 0x593b26cd5000
22:16:45.821598 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0
22:16:45.821770 write(1, "Type file's name: ", 18) = 18
22:16:45.821998 rt_sigaction(SIGINT, {sa_handler=SIG_IGN, sa_mask=[], sa_flags=SA_RESTORER, sa_restorer=0x70a91c045330}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
22:16:45.822296 rt_sigaction(SIGQUIT, {sa_handler=SIG_IGN, sa_mask=[], sa_flags=SA_RESTORER, sa_restorer=0x70a91c045330}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
22:16:45.822544 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
22:16:45.822741 mmap(NULL, 36864, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x70a91c6a0000
22:16:45.823052 rt_sigprocmask(SIG_BLOCK, ~[], [CHLD], 8) = 0
22:16:45.823273 clone3({flags=CLONE_VM|CLONE_VFORK|CLONE_CLEAR_SIGHAND, exit_signal=SIGCHLD, stack=0x70a91c6a0000, stack_size=0x9000}, 88) = 25040
22:16:45.825216 munmap(0x70a91c6a0000, 36864) = 0
22:16:45.825450 rt_sigprocmask(SIG_SETMASK, [CHLD], NULL, 8) = 0
22:16:45.826410 wait4(25040, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0, NULL) = 25040
22:17:21.139618 rt_sigaction(SIGINT, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=SA_RESTORER, sa_restorer=0x70a91c045330}, NULL, 8) = 0
22:17:21.139708 rt_sigaction(SIGQUIT, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=SA_RESTORER, sa_restorer=0x70a91c045330}, NULL, 8) = 0
22:17:21.139731 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
22:17:21.140250 --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=25040, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
22:17:21.140387 write(1, "Program finished", 16) = 16
22:17:21.140829 exit_group(0)           = ?
22:17:21.141520 +++ exited with 0 +++
\end{verbatim}

\section{Пример работы программы}

\subsection*{Ввод данных}
\begin{verbatim}
Type file's name: results.txt
Write numbers separated by space (first divides by others):
For exit write 'q'
Write numbers: 100 2 5
Write numbers: 50 2 2.5
Write numbers: 10 0 5
Divide by zero. Program is closing
Program finished
\end{verbatim}

\subsection*{Содержимое файла results.txt}
\begin{verbatim}
100 / 2 / 5 = 10
50 / 2 / 2.5 = 10
Fault: division by zero
\end{verbatim}

\section*{Вывод}

В ходе выполнения лабораторной работы была успешно реализована программа для выполнения операций деления с использованием взаимодействия процессов через разделяемую память. Основные достижения и наблюдения:

\begin{enumerate}
    \item \textbf{Взаимодействие процессов}: Программа корректно реализует взаимодействие между родительским и дочерним процессами с использованием механизма разделяемой памяти (shared memory).

    \item \textbf{Обработка ошибок}: Реализована надежная обработка ошибок, включая проверку деления на ноль в дочернем процессе и корректное завершение работы обоих процессов при обнаружении ошибки.

    \item \textbf{Синхронизация}: Использование атомарных флагов обеспечивает правильную синхронизацию между процессами без необходимости использования дополнительных механизмов синхронизации.

    \item \textbf{Работа с файловой системой}: Программа успешно записывает результаты операций в файл, демонстрируя практические навыки работы с файловыми системами.

    \item \textbf{Обработка пользовательского ввода}: Реализован удобный интерфейс для ввода данных с возможностью многократного ввода чисел и корректного завершения работы.

    \item \textbf{Системные вызовы}: Программа эффективно использует системные вызовы для работы с процессами и разделяемой памятью, включая \texttt{fork()}, \texttt{shm\_open()}, \texttt{mmap()} и другие.
\end{enumerate}

Программа демонстрирует практическое применение технологии «File mapping» для обмена данными между процессами и может служить основой для разработки более сложных многопроцессных приложений.

\end{document}